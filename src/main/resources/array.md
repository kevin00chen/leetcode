　　主要记录数组相关的题目。

[TOC]

### 1 [两数求和](../java/com/ckm/array/Solution1.java)
问题描述：

　　给定一个整数数组，返回和为指定数字的元素下标。每个元素只能使用一次。

示例：
```
nums = [2, 7, 11, 15], target = 9,

nums[0] + nums[1] = 2 + 7 = 9,

返回 [0, 1].
```
解法：

　　除了两层遍历的暴力解法之外，还可以用HashMap来解决，遍历数组，target - 当前元素 之差如果不在该map中，则map中添加元素，否则直接返回下标。

### 4 [两个有序数组中位数计算](../java/com/ckm/array/Solution4.java)
问题描述：

　　两个排好序的数组（两个数组不同时为空），分别包含m个和n个元素，计算中位数。时间复杂度`O(log (m+n))`

示例：

```
Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```

解法：

　　

### 11 [整数数组最大容量](../java/com/ckm/array/Solution1.java)
问题描述：

　　给定一个`n`维整数数组`a1, a2, ..., an`，每个数字代表当前点位的高度，找到两个点，构成一个容器，使得该容器中可以盛最多的水，如下图所示。`n >= 2`。

![示意图](./images/q_11.jpg)

　　上图中的数组为`[1,8,6,2,5,4,8,3,7]`，所以，在这个示例中，最大容量为蓝色部分，容量为49。

示例：

```
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

解法：

1、暴力解法

　　双重遍历，遇到更大size则更新。

2、双指诊遍历

　　用指针`i, j`指向数组头尾，当`i, j`未重叠时，依次向里收缩，每次都是矮的那个移动。比如当`height[i] < height[j]`时，如果此时的`i, j`为最大容量，
如果移动`height[j]`，并不会增大整个容量，因为雨水的最大高度由矮的那边决定，移动高边只会使容量更小。只有移动矮边，如果接下来高度能够得到提升，才有可能进一步增大容量。

### 287 [整数数组重复数字](../java/com/ckm/array/Solution287.java)
问题描述：

　　给定一个包含`n + 1`个整数的数组，数组中的元素取值范围为`1 ~ n`。找到重复出现多次的数字，仅有一个重复数字。

　　限制条件:
- 不能改变原数组结构，数组为只读
- 空间复杂度`O(1)`
- 时间复杂度`O(n^2)`
- 重复数字可能会出现超过两次

示例：

```
Example 1:

Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
```

解法：

　　由于限制条件的存在，`O(1)`空间复杂度，无法使用`Map`结构，并且重复数字可能出现多次，所以无法用一些数学技巧，或者异或操作。

1、二分查找

　　对于一个连续的数组`1 ~ n`，在补重复的情况下，小于`i`的元素有`i - 1`个，大于`i`的元素有`n - i`个。如果某个区间的元素个数不符合该情况，则说明该区间出现重复数字，继续二分查找。

2、快慢指针

　　如果以数组中元素为下标遍历该数组的话，由于出现重复元素，所以会有某些元素将会遍历多次，即形成环，环的入口就是重复元素。对于链表是否有环的一个常见思路是快慢指针。

　　以数组中的元素值表示下一个元素的下标，如果某个元素值恰好与它自己所在位置的数组下标相等，并且该元素不重复的话，将永远不会出现在该链表中，因为没办法从外部进入该元素。
如果该元素被访问到，那么说明在其他下标处有一个相同值的元素，最终链表将会以该数字重复出现。
如果重复元素的值不等于所在数组位置下标，最终该链表会以两个数字循环。

### 15 [三数求和](../java/com/ckm/array/Solution15.java)
问题描述：

　　给定一个整数数组，其中是否存在三个整数`a, b, c`使得`a + b + c = 0`，找到所有的不同组合。

示例：

```
Example:
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

解法：

　　首先对数组进行排序，一方面可以避免对重复元素的重复处理，另一方面还可以在后续调整索引方向时使用。
如果目标值过大，则调整右边向左移动。如果目标值过小，则调整左边向右移动。

### 16 [最接近目标值的三数求和](../java/com/ckm/array/Solution16.java)
问题描述：

　　给定一个整数数组，以及一个目标整数。找到数组中三个元素和最接近目标整数的和，该题目中只存在一种组合情况。

示例：

```
  Example:
  
  Given array nums = [-1, 2, 1, -4], and target = 1.
  
  The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```

解法：

　　和上一题类似。

### 18 [四数求和](../java/com/ckm/array/Solution18.java)
问题描述：

　　给定一个整数数组，以及一个目标值。找到所有使`a + b + c + d = target`的元素组合。

示例：

```
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

解法：

　　和三数求和类似，直接套用三数求和的代码，将三数求和的结果由`0`改为输入的第一个数字相反数。

### 53 [最大连续子数组和](../java/com/ckm/array/Solution1.java)
问题描述：

　　给定一个整数数组，找到其中和最大的一段连续子数组(最少包含一个数字)，返回sum值。
可以尝试一下分治策略。

示例：

```
Example:
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

解法：

　　动态规划，递推关系式为`Math.max(fn[i - 1] + nums[i], nums[i])`


### 8 [](../java/com/ckm/array/Solution1.java)
问题描述：

　　

示例：


解法：

　　
